---
globs: *.dart
description: Dart language best practices and coding standards
---

# Dart Best Practices

Follow these Dart language best practices for clean, maintainable code.

## Effective Dart Guidelines
- **Follow Effective Dart:** Adhere to the official Effective Dart guidelines (https://dart.dev/effective-dart)
- **Class Organization:** Define related classes within the same library file. For large libraries, export smaller, private libraries from a single top-level library
- **Library Organization:** Group related libraries in the same folder

## Code Structure
- **API Documentation:** Add documentation comments to all public APIs, including classes, constructors, methods, and top-level functions
- **Comments:** Write clear comments for complex or non-obvious code. Avoid over-commenting
- **Trailing Comments:** Don't add trailing comments
- **Conciseness:** Write code that is as short as it can be while remaining clear
- **Simplicity:** Write straightforward code. Code that is clever or obscure is difficult to maintain

## Null Safety
- **Null Safety:** Write code that is soundly null-safe. Leverage Dart's null safety features
- **Avoid `!`:** Avoid `!` unless the value is guaranteed to be non-null
- **Null-aware operators:** Use `?.`, `??`, and `??=` for safe null handling

## Async Programming
- **Async/Await:** Ensure proper use of `async`/`await` for asynchronous operations with robust error handling
- **Futures:** Use `Future`s, `async`, and `await` for asynchronous operations
- **Streams:** Use `Stream`s for sequences of asynchronous events
- **Error Handling:** Use `try-catch` blocks for handling exceptions, and use exceptions appropriate for the type of exception

## Modern Dart Features
- **Pattern Matching:** Use pattern matching features where they simplify the code
- **Records:** Use records to return multiple types in situations where defining an entire class is cumbersome
- **Switch Statements:** Prefer using exhaustive `switch` statements or expressions, which don't require `break` statements
- **Arrow Functions:** Use arrow syntax for simple one-line functions

## Exception Handling
- **Custom Exceptions:** Use custom exceptions for situations specific to your code
- **Try-Catch:** Use `try-catch` blocks for handling exceptions
- **Error Propagation:** Don't let your code fail silently

## Documentation
- **Doc Comments:** Use `///` for doc comments to allow documentation generation tools to pick them up
- **Summary:** Start with a single-sentence summary ending with a period
- **Separate Summary:** Add a blank line after the first sentence to create a separate paragraph
- **Avoid Redundancy:** Don't repeat information that's obvious from the code's context
- **Code Samples:** Include code samples where appropriate to illustrate usage
- **Parameters and Returns:** Explain parameters, return values, and exceptions using prose

## Testing Considerations
- **Testable Code:** Write code with testing in mind
- **Dependency Injection:** Use simple manual constructor dependency injection to make a class's dependencies explicit
- **Mocking:** Use the `file`, `process`, and `platform` packages, if appropriate, so you can inject in-memory and fake versions of objects