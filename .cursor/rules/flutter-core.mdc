---
alwaysApply: true
description: Core Flutter development guidelines and best practices
---

# Flutter Core Development Rules

You are an expert in Flutter and Dart development. Follow these core principles when working with Flutter applications.

## Project Structure
- **Entry Point:** The main entry point is [lib/main.dart](mdc:lib/main.dart)
- **Standard Structure:** Follow standard Flutter project structure with `lib/main.dart` as the primary application entry point
- **Feature Organization:** For larger projects, organize code by feature with presentation, domain, and data subfolders

## Flutter Style Guide
- **SOLID Principles:** Apply SOLID principles throughout the codebase
- **Concise and Declarative:** Write concise, modern, technical Dart code. Prefer functional and declarative patterns
- **Composition over Inheritance:** Favor composition for building complex widgets and logic
- **Immutability:** Prefer immutable data structures. Widgets (especially `StatelessWidget`) should be immutable
- **Widgets are for UI:** Everything in Flutter's UI is a widget. Compose complex UIs from smaller, reusable widgets

## Code Quality
- **Naming Conventions:** 
  - Use `PascalCase` for classes
  - Use `camelCase` for members/variables/functions/enums
  - Use `snake_case` for files
- **Line Length:** Lines should be 80 characters or fewer
- **Functions:** Keep functions short and with a single purpose (strive for less than 20 lines)
- **Error Handling:** Anticipate and handle potential errors. Don't let code fail silently
- **Logging:** Use the `logging` package instead of `print`

## Widget Best Practices
- **Immutability:** Widgets (especially `StatelessWidget`) are immutable; when the UI needs to change, Flutter rebuilds the widget tree
- **Composition:** Prefer composing smaller widgets over extending existing ones
- **Private Widgets:** Use small, private `Widget` classes instead of private helper methods that return a `Widget`
- **Build Methods:** Break down large `build()` methods into smaller, reusable private Widget classes
- **Const Constructors:** Use `const` constructors for widgets and in `build()` methods whenever possible to reduce rebuilds
- **Build Method Performance:** Avoid performing expensive operations, like network calls or complex computations, directly within `build()` methods

## Performance
- **List Performance:** Use `ListView.builder` or `SliverList` for long lists to create lazy-loaded lists for performance
- **Isolates:** Use `compute()` to run expensive calculations in a separate isolate to avoid blocking the UI thread
- **Responsive UI:** Use `LayoutBuilder` or `MediaQuery` to create responsive UIs

## Navigation
- **GoRouter:** Use the `go_router` package for declarative navigation, deep linking, and web support
- **Navigator:** Use the built-in `Navigator` for short-lived screens that do not need to be deep-linkable, such as dialogs or temporary views

## Package Management
- **Adding Dependencies:** Use `flutter pub add <package_name>` for regular dependencies
- **Adding Dev Dependencies:** Use `flutter pub add dev:<package_name>` for development dependencies
- **Removing Dependencies:** Use `dart pub remove <package_name>` to remove dependencies